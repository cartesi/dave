#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen 0.69.2 */

pub const _ASSERT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CM_MACHINE_HASH_BYTE_SIZE: u32 = 32;
pub const CM_MACHINE_X_REG_COUNT: u32 = 32;
pub const CM_MACHINE_F_REG_COUNT: u32 = 32;
pub const CM_MACHINE_UARCH_X_REG_COUNT: u32 = 32;
pub const CM_TREE_LOG2_WORD_SIZE: u32 = 3;
pub const CM_TREE_LOG2_PAGE_SIZE: u32 = 12;
pub const CM_TREE_LOG2_ROOT_SIZE: u32 = 64;
pub const CM_FLASH_DRIVE_CONFIGS_MAX_SIZE: u32 = 8;
pub const CM_MARCHID: u32 = 15;
pub const CM_VERSION_MAJOR: u32 = 0;
pub const CM_VERSION_MINOR: u32 = 15;
pub const CM_VERSION_PATCH: u32 = 2;
pub const CM_VERSION_LABEL: &[u8; 1] = b"\0";
pub const CM_MIMPID: u32 = 15;
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type cm_hash = [u8; 32usize];
#[doc = " \\brief Array of hashes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_hash_array {
    pub entry: *mut cm_hash,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_cm_hash_array() {
    const UNINIT: ::std::mem::MaybeUninit<cm_hash_array> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_hash_array>(),
        16usize,
        concat!("Size of: ", stringify!(cm_hash_array))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_hash_array>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_hash_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_hash_array),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_hash_array),
            "::",
            stringify!(count)
        )
    );
}
pub const CM_ERROR_CM_ERROR_OK: CM_ERROR = 0;
pub const CM_ERROR_CM_ERROR_INVALID_ARGUMENT: CM_ERROR = 1;
pub const CM_ERROR_CM_ERROR_DOMAIN_ERROR: CM_ERROR = 2;
pub const CM_ERROR_CM_ERROR_LENGTH_ERROR: CM_ERROR = 3;
pub const CM_ERROR_CM_ERROR_OUT_OF_RANGE: CM_ERROR = 4;
pub const CM_ERROR_CM_ERROR_LOGIC_ERROR: CM_ERROR = 5;
pub const CM_ERROR_CM_LOGIC_ERROR_END: CM_ERROR = 6;
pub const CM_ERROR_CM_ERROR_BAD_OPTIONAL_ACCESS: CM_ERROR = 7;
pub const CM_ERROR_CM_ERROR_RUNTIME_ERROR: CM_ERROR = 8;
pub const CM_ERROR_CM_ERROR_RANGE_ERROR: CM_ERROR = 9;
pub const CM_ERROR_CM_ERROR_OVERFLOW_ERROR: CM_ERROR = 10;
pub const CM_ERROR_CM_ERROR_UNDERFLOW_ERROR: CM_ERROR = 11;
pub const CM_ERROR_CM_ERROR_REGEX_ERROR: CM_ERROR = 12;
pub const CM_ERROR_CM_ERROR_SYSTEM_IOS_BASE_FAILURE: CM_ERROR = 13;
pub const CM_ERROR_CM_ERROR_FILESYSTEM_ERROR: CM_ERROR = 14;
pub const CM_ERROR_CM_ERROR_ATOMIC_TX_ERROR: CM_ERROR = 15;
pub const CM_ERROR_CM_ERROR_NONEXISTING_LOCAL_TIME: CM_ERROR = 16;
pub const CM_ERROR_CM_ERROR_AMBIGOUS_LOCAL_TIME: CM_ERROR = 17;
pub const CM_ERROR_CM_ERROR_FORMAT_ERROR: CM_ERROR = 18;
pub const CM_ERROR_CM_RUNTIME_ERROR_END: CM_ERROR = 19;
pub const CM_ERROR_CM_ERROR_BAD_TYPEID: CM_ERROR = 20;
pub const CM_ERROR_CM_ERROR_BAD_CAST: CM_ERROR = 21;
pub const CM_ERROR_CM_ERROR_BAD_ANY_CAST: CM_ERROR = 22;
pub const CM_ERROR_CM_ERROR_BAD_WEAK_PTR: CM_ERROR = 23;
pub const CM_ERROR_CM_ERROR_BAD_FUNCTION_CALL: CM_ERROR = 24;
pub const CM_ERROR_CM_ERROR_BAD_ALLOC: CM_ERROR = 25;
pub const CM_ERROR_CM_ERROR_BAD_ARRAY_NEW_LENGTH: CM_ERROR = 26;
pub const CM_ERROR_CM_ERROR_BAD_EXCEPTION: CM_ERROR = 27;
pub const CM_ERROR_CM_ERROR_BAD_VARIANT_ACCESS: CM_ERROR = 28;
pub const CM_ERROR_CM_ERROR_EXCEPTION: CM_ERROR = 29;
pub const CM_ERROR_CM_OTHER_ERROR_END: CM_ERROR = 30;
pub const CM_ERROR_CM_ERROR_UNKNOWN: CM_ERROR = 31;
#[doc = " brief Error codes returned from machine emulator C API"]
pub type CM_ERROR = ::std::os::raw::c_uint;
pub const CM_BREAK_REASON_CM_BREAK_REASON_FAILED: CM_BREAK_REASON = 0;
pub const CM_BREAK_REASON_CM_BREAK_REASON_HALTED: CM_BREAK_REASON = 1;
pub const CM_BREAK_REASON_CM_BREAK_REASON_YIELDED_MANUALLY: CM_BREAK_REASON = 2;
pub const CM_BREAK_REASON_CM_BREAK_REASON_YIELDED_AUTOMATICALLY: CM_BREAK_REASON = 3;
pub const CM_BREAK_REASON_CM_BREAK_REASON_REACHED_TARGET_MCYCLE: CM_BREAK_REASON = 4;
#[doc = " \\brief Reasons for a machine run interruption"]
pub type CM_BREAK_REASON = ::std::os::raw::c_uint;
pub const CM_PROC_CSR_CM_PROC_PC: CM_PROC_CSR = 0;
pub const CM_PROC_CSR_CM_PROC_FCSR: CM_PROC_CSR = 1;
pub const CM_PROC_CSR_CM_PROC_MVENDORID: CM_PROC_CSR = 2;
pub const CM_PROC_CSR_CM_PROC_MARCHID: CM_PROC_CSR = 3;
pub const CM_PROC_CSR_CM_PROC_MIMPID: CM_PROC_CSR = 4;
pub const CM_PROC_CSR_CM_PROC_MCYCLE: CM_PROC_CSR = 5;
pub const CM_PROC_CSR_CM_PROC_ICYCLEINSTRET: CM_PROC_CSR = 6;
pub const CM_PROC_CSR_CM_PROC_MSTATUS: CM_PROC_CSR = 7;
pub const CM_PROC_CSR_CM_PROC_MTVEC: CM_PROC_CSR = 8;
pub const CM_PROC_CSR_CM_PROC_MSCRATCH: CM_PROC_CSR = 9;
pub const CM_PROC_CSR_CM_PROC_MEPC: CM_PROC_CSR = 10;
pub const CM_PROC_CSR_CM_PROC_MCAUSE: CM_PROC_CSR = 11;
pub const CM_PROC_CSR_CM_PROC_MTVAL: CM_PROC_CSR = 12;
pub const CM_PROC_CSR_CM_PROC_MISA: CM_PROC_CSR = 13;
pub const CM_PROC_CSR_CM_PROC_MIE: CM_PROC_CSR = 14;
pub const CM_PROC_CSR_CM_PROC_MIP: CM_PROC_CSR = 15;
pub const CM_PROC_CSR_CM_PROC_MEDELEG: CM_PROC_CSR = 16;
pub const CM_PROC_CSR_CM_PROC_MIDELEG: CM_PROC_CSR = 17;
pub const CM_PROC_CSR_CM_PROC_MCOUNTEREN: CM_PROC_CSR = 18;
pub const CM_PROC_CSR_CM_PROC_MENVCFG: CM_PROC_CSR = 19;
pub const CM_PROC_CSR_CM_PROC_STVEC: CM_PROC_CSR = 20;
pub const CM_PROC_CSR_CM_PROC_SSCRATCH: CM_PROC_CSR = 21;
pub const CM_PROC_CSR_CM_PROC_SEPC: CM_PROC_CSR = 22;
pub const CM_PROC_CSR_CM_PROC_SCAUSE: CM_PROC_CSR = 23;
pub const CM_PROC_CSR_CM_PROC_STVAL: CM_PROC_CSR = 24;
pub const CM_PROC_CSR_CM_PROC_SATP: CM_PROC_CSR = 25;
pub const CM_PROC_CSR_CM_PROC_SCOUNTEREN: CM_PROC_CSR = 26;
pub const CM_PROC_CSR_CM_PROC_SENVCFG: CM_PROC_CSR = 27;
pub const CM_PROC_CSR_CM_PROC_ILRSC: CM_PROC_CSR = 28;
pub const CM_PROC_CSR_CM_PROC_IFLAGS: CM_PROC_CSR = 29;
pub const CM_PROC_CSR_CM_PROC_CLINT_MTIMECMP: CM_PROC_CSR = 30;
pub const CM_PROC_CSR_CM_PROC_HTIF_TOHOST: CM_PROC_CSR = 31;
pub const CM_PROC_CSR_CM_PROC_HTIF_FROMHOST: CM_PROC_CSR = 32;
pub const CM_PROC_CSR_CM_PROC_HTIF_IHALT: CM_PROC_CSR = 33;
pub const CM_PROC_CSR_CM_PROC_HTIF_ICONSOLE: CM_PROC_CSR = 34;
pub const CM_PROC_CSR_CM_PROC_HTIF_IYIELD: CM_PROC_CSR = 35;
pub const CM_PROC_CSR_CM_PROC_UARCH_PC: CM_PROC_CSR = 36;
pub const CM_PROC_CSR_CM_PROC_UARCH_CYCLE: CM_PROC_CSR = 37;
pub const CM_PROC_CSR_CM_PROC_UARCH_HALT_FLAG: CM_PROC_CSR = 38;
pub const CM_PROC_CSR_CM_PROC_UNKNOWN: CM_PROC_CSR = 39;
#[doc = " \\brief List of CSRs to use with read_csr and write_csr"]
pub type CM_PROC_CSR = ::std::os::raw::c_uint;
pub const CM_UARCH_BREAK_REASON_CM_UARCH_BREAK_REASON_REACHED_TARGET_CYCLE: CM_UARCH_BREAK_REASON =
    0;
pub const CM_UARCH_BREAK_REASON_CM_UARCH_BREAK_REASON_UARCH_HALTED: CM_UARCH_BREAK_REASON = 1;
#[doc = " \\brief Return values of uarch_interpret"]
pub type CM_UARCH_BREAK_REASON = ::std::os::raw::c_uint;
#[doc = " \\brief Processor state configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_processor_config {
    #[doc = "< Value of general-purpose registers"]
    pub x: [u64; 32usize],
    #[doc = "< Value of floating-point registers"]
    pub f: [u64; 32usize],
    #[doc = "< Value of pc"]
    pub pc: u64,
    #[doc = "< Value of fcsr CSR"]
    pub fcsr: u64,
    #[doc = "< Value of mvendorid CSR"]
    pub mvendorid: u64,
    #[doc = "< Value of marchid CSR"]
    pub marchid: u64,
    #[doc = "< Value of mimpid CSR"]
    pub mimpid: u64,
    #[doc = "< Value of mcycle CSR"]
    pub mcycle: u64,
    #[doc = "< Value of icycleinstret CSR"]
    pub icycleinstret: u64,
    #[doc = "< Value of mstatus CSR"]
    pub mstatus: u64,
    #[doc = "< Value of mtvec CSR"]
    pub mtvec: u64,
    #[doc = "< Value of mscratch CSR"]
    pub mscratch: u64,
    #[doc = "< Value of mepc CSR"]
    pub mepc: u64,
    #[doc = "< Value of mcause CSR"]
    pub mcause: u64,
    #[doc = "< Value of mtval CSR"]
    pub mtval: u64,
    #[doc = "< Value of misa CSR"]
    pub misa: u64,
    #[doc = "< Value of mie CSR"]
    pub mie: u64,
    #[doc = "< Value of mip CSR"]
    pub mip: u64,
    #[doc = "< Value of medeleg CSR"]
    pub medeleg: u64,
    #[doc = "< Value of mideleg CSR"]
    pub mideleg: u64,
    #[doc = "< Value of mcounteren CSR"]
    pub mcounteren: u64,
    #[doc = "< Value of menvcfg CSR"]
    pub menvcfg: u64,
    #[doc = "< Value of stvec CSR"]
    pub stvec: u64,
    #[doc = "< Value of sscratch CSR"]
    pub sscratch: u64,
    #[doc = "< Value of sepc CSR"]
    pub sepc: u64,
    #[doc = "< Value of scause CSR"]
    pub scause: u64,
    #[doc = "< Value of stval CSR"]
    pub stval: u64,
    #[doc = "< Value of satp CSR"]
    pub satp: u64,
    #[doc = "< Value of scounteren CSR"]
    pub scounteren: u64,
    #[doc = "< Value of senvcfg CSR"]
    pub senvcfg: u64,
    #[doc = "< Value of ilrsc CSR"]
    pub ilrsc: u64,
    #[doc = "< Value of iflags CSR"]
    pub iflags: u64,
}
#[test]
fn bindgen_test_layout_cm_processor_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_processor_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_processor_config>(),
        752usize,
        concat!("Size of: ", stringify!(cm_processor_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_processor_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_processor_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcsr) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(fcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mvendorid) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mvendorid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marchid) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(marchid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mimpid) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mimpid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcycle) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mcycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).icycleinstret) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(icycleinstret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mstatus) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mstatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtvec) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mtvec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mscratch) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mscratch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mepc) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mepc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcause) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mcause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtval) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mtval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).misa) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(misa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mie) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mip) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).medeleg) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(medeleg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mideleg) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mideleg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcounteren) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(mcounteren)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).menvcfg) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(menvcfg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stvec) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(stvec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sscratch) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(sscratch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sepc) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(sepc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scause) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(scause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stval) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(stval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).satp) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(satp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scounteren) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(scounteren)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).senvcfg) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(senvcfg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ilrsc) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(ilrsc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iflags) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_processor_config),
            "::",
            stringify!(iflags)
        )
    );
}
#[doc = " \\brief RAM state configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_ram_config {
    #[doc = "< RAM length"]
    pub length: u64,
    #[doc = "< RAM image file name"]
    pub image_filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cm_ram_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_ram_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_ram_config>(),
        16usize,
        concat!("Size of: ", stringify!(cm_ram_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_ram_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_ram_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_ram_config),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_ram_config),
            "::",
            stringify!(image_filename)
        )
    );
}
#[doc = " \\brief DTB state configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_dtb_config {
    #[doc = "< Bootargs to pass to kernel"]
    pub bootargs: *const ::std::os::raw::c_char,
    #[doc = "< Initialization commands to be executed as root on boot"]
    pub init: *const ::std::os::raw::c_char,
    #[doc = "< Commands to execute the main application"]
    pub entrypoint: *const ::std::os::raw::c_char,
    #[doc = "< ROM image file"]
    pub image_filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cm_dtb_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_dtb_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_dtb_config>(),
        32usize,
        concat!("Size of: ", stringify!(cm_dtb_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_dtb_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_dtb_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bootargs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_dtb_config),
            "::",
            stringify!(bootargs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_dtb_config),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entrypoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_dtb_config),
            "::",
            stringify!(entrypoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_filename) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_dtb_config),
            "::",
            stringify!(image_filename)
        )
    );
}
#[doc = " \\brief Memory range configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_memory_range_config {
    #[doc = "< Memory range start position"]
    pub start: u64,
    #[doc = "< Memory range length"]
    pub length: u64,
    #[doc = "< Target changes to range affect image file?"]
    pub shared: bool,
    #[doc = "< Memory range image file name"]
    pub image_filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cm_memory_range_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_memory_range_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_memory_range_config>(),
        32usize,
        concat!("Size of: ", stringify!(cm_memory_range_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_memory_range_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_memory_range_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_config),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_config),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_config),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_filename) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_config),
            "::",
            stringify!(image_filename)
        )
    );
}
#[doc = " \\brief Memory range configuration array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_memory_range_config_array {
    pub entry: *mut cm_memory_range_config,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_cm_memory_range_config_array() {
    const UNINIT: ::std::mem::MaybeUninit<cm_memory_range_config_array> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_memory_range_config_array>(),
        16usize,
        concat!("Size of: ", stringify!(cm_memory_range_config_array))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_memory_range_config_array>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_memory_range_config_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_config_array),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_config_array),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " \\brief TLB device state configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_tlb_config {
    #[doc = "< TLB image file name"]
    pub image_filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cm_tlb_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_tlb_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_tlb_config>(),
        8usize,
        concat!("Size of: ", stringify!(cm_tlb_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_tlb_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_tlb_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_filename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_tlb_config),
            "::",
            stringify!(image_filename)
        )
    );
}
#[doc = " \\brief CLINT device state configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_clint_config {
    #[doc = "< Value of mtimecmp CSR"]
    pub mtimecmp: u64,
}
#[test]
fn bindgen_test_layout_cm_clint_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_clint_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_clint_config>(),
        8usize,
        concat!("Size of: ", stringify!(cm_clint_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_clint_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_clint_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtimecmp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_clint_config),
            "::",
            stringify!(mtimecmp)
        )
    );
}
#[doc = " \\brief HTIF device state configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_htif_config {
    #[doc = "< Value of fromhost CSR"]
    pub fromhost: u64,
    #[doc = "< Value of tohost CSR"]
    pub tohost: u64,
    #[doc = "< Make console getchar available?"]
    pub console_getchar: bool,
    #[doc = "< Make yield manual available?"]
    pub yield_manual: bool,
    #[doc = "< Make yield automatic available?"]
    pub yield_automatic: bool,
}
#[test]
fn bindgen_test_layout_cm_htif_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_htif_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_htif_config>(),
        24usize,
        concat!("Size of: ", stringify!(cm_htif_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_htif_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_htif_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fromhost) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_htif_config),
            "::",
            stringify!(fromhost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tohost) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_htif_config),
            "::",
            stringify!(tohost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).console_getchar) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_htif_config),
            "::",
            stringify!(console_getchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yield_manual) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_htif_config),
            "::",
            stringify!(yield_manual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yield_automatic) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_htif_config),
            "::",
            stringify!(yield_automatic)
        )
    );
}
#[doc = " \\brief Rollup state configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_rollup_config {
    #[doc = "< Represents whether the rest of the struct have been filled"]
    pub has_value: bool,
    #[doc = "< RX buffer memory range"]
    pub rx_buffer: cm_memory_range_config,
    #[doc = "< TX buffer memory range"]
    pub tx_buffer: cm_memory_range_config,
}
#[test]
fn bindgen_test_layout_cm_rollup_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_rollup_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_rollup_config>(),
        72usize,
        concat!("Size of: ", stringify!(cm_rollup_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_rollup_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_rollup_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_rollup_config),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_rollup_config),
            "::",
            stringify!(rx_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_buffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_rollup_config),
            "::",
            stringify!(tx_buffer)
        )
    );
}
#[doc = " \\brief microarchitecture RAM configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_uarch_ram_config {
    #[doc = "< RAM image file name"]
    pub image_filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cm_uarch_ram_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_uarch_ram_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_uarch_ram_config>(),
        8usize,
        concat!("Size of: ", stringify!(cm_uarch_ram_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_uarch_ram_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_uarch_ram_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_filename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_uarch_ram_config),
            "::",
            stringify!(image_filename)
        )
    );
}
#[doc = " \\brief Microarchitecture processor configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_uarch_processor_config {
    pub x: [u64; 32usize],
    pub pc: u64,
    pub cycle: u64,
    pub halt_flag: bool,
}
#[test]
fn bindgen_test_layout_cm_uarch_processor_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_uarch_processor_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_uarch_processor_config>(),
        280usize,
        concat!("Size of: ", stringify!(cm_uarch_processor_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_uarch_processor_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_uarch_processor_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_uarch_processor_config),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_uarch_processor_config),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cycle) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_uarch_processor_config),
            "::",
            stringify!(cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).halt_flag) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_uarch_processor_config),
            "::",
            stringify!(halt_flag)
        )
    );
}
#[doc = " \\brief Microarchitecture state configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_uarch_config {
    pub processor: cm_uarch_processor_config,
    pub ram: cm_uarch_ram_config,
}
#[test]
fn bindgen_test_layout_cm_uarch_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_uarch_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_uarch_config>(),
        288usize,
        concat!("Size of: ", stringify!(cm_uarch_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_uarch_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_uarch_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_uarch_config),
            "::",
            stringify!(processor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ram) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_uarch_config),
            "::",
            stringify!(ram)
        )
    );
}
#[doc = " \\brief Machine state configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_machine_config {
    pub processor: cm_processor_config,
    pub ram: cm_ram_config,
    pub dtb: cm_dtb_config,
    pub flash_drive: cm_memory_range_config_array,
    pub tlb: cm_tlb_config,
    pub clint: cm_clint_config,
    pub htif: cm_htif_config,
    pub rollup: cm_rollup_config,
    pub uarch: cm_uarch_config,
}
#[test]
fn bindgen_test_layout_cm_machine_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_machine_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_machine_config>(),
        1216usize,
        concat!("Size of: ", stringify!(cm_machine_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_machine_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_machine_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_config),
            "::",
            stringify!(processor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ram) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_config),
            "::",
            stringify!(ram)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dtb) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_config),
            "::",
            stringify!(dtb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flash_drive) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_config),
            "::",
            stringify!(flash_drive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_config),
            "::",
            stringify!(tlb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clint) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_config),
            "::",
            stringify!(clint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htif) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_config),
            "::",
            stringify!(htif)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rollup) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_config),
            "::",
            stringify!(rollup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uarch) as usize - ptr as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_config),
            "::",
            stringify!(uarch)
        )
    );
}
#[doc = " \\brief Merkle tree proof structure\n \\details\n This structure holds a proof that the node spanning a log2_target_size\n at a given address in the tree has a certain hash."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_merkle_tree_proof {
    pub target_address: u64,
    pub log2_target_size: usize,
    pub target_hash: cm_hash,
    pub log2_root_size: usize,
    pub root_hash: cm_hash,
    pub sibling_hashes: cm_hash_array,
}
#[test]
fn bindgen_test_layout_cm_merkle_tree_proof() {
    const UNINIT: ::std::mem::MaybeUninit<cm_merkle_tree_proof> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_merkle_tree_proof>(),
        104usize,
        concat!("Size of: ", stringify!(cm_merkle_tree_proof))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_merkle_tree_proof>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_merkle_tree_proof))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_merkle_tree_proof),
            "::",
            stringify!(target_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_target_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_merkle_tree_proof),
            "::",
            stringify!(log2_target_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_hash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_merkle_tree_proof),
            "::",
            stringify!(target_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_root_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_merkle_tree_proof),
            "::",
            stringify!(log2_root_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_hash) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_merkle_tree_proof),
            "::",
            stringify!(root_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sibling_hashes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_merkle_tree_proof),
            "::",
            stringify!(sibling_hashes)
        )
    );
}
#[doc = "< Read operation"]
pub const CM_ACCESS_TYPE_CM_ACCESS_READ: CM_ACCESS_TYPE = 0;
#[doc = "< Write operation"]
pub const CM_ACCESS_TYPE_CM_ACCESS_WRITE: CM_ACCESS_TYPE = 1;
#[doc = " \\brief Type of state access"]
pub type CM_ACCESS_TYPE = ::std::os::raw::c_uint;
#[doc = " \\brief Type of access log"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_access_log_type {
    #[doc = "< Includes proofs"]
    pub proofs: bool,
    #[doc = "< Includes annotations"]
    pub annotations: bool,
    #[doc = "< Includes data bigger than 8 bytes"]
    pub large_data: bool,
}
#[test]
fn bindgen_test_layout_cm_access_log_type() {
    const UNINIT: ::std::mem::MaybeUninit<cm_access_log_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_access_log_type>(),
        3usize,
        concat!("Size of: ", stringify!(cm_access_log_type))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_access_log_type>(),
        1usize,
        concat!("Alignment of ", stringify!(cm_access_log_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proofs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access_log_type),
            "::",
            stringify!(proofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access_log_type),
            "::",
            stringify!(annotations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).large_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access_log_type),
            "::",
            stringify!(large_data)
        )
    );
}
#[doc = "< Start of scope"]
pub const CM_BRACKET_TYPE_CM_BRACKET_BEGIN: CM_BRACKET_TYPE = 0;
#[doc = "< End of scope"]
pub const CM_BRACKET_TYPE_CM_BRACKET_END: CM_BRACKET_TYPE = 1;
#[doc = " \\brief Bracket type"]
pub type CM_BRACKET_TYPE = ::std::os::raw::c_uint;
#[doc = " \\brief Bracket note"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_bracket_note {
    #[doc = "< Bracket type"]
    pub type_: CM_BRACKET_TYPE,
    #[doc = "< Where it points to in the log"]
    pub where_: u64,
    #[doc = "< Note text"]
    pub text: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cm_bracket_note() {
    const UNINIT: ::std::mem::MaybeUninit<cm_bracket_note> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_bracket_note>(),
        24usize,
        concat!("Size of: ", stringify!(cm_bracket_note))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_bracket_note>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_bracket_note))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_bracket_note),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).where_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_bracket_note),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_bracket_note),
            "::",
            stringify!(text)
        )
    );
}
#[doc = " \\brief Records an access to the machine state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_access {
    #[doc = "< Type of access"]
    pub type_: CM_ACCESS_TYPE,
    #[doc = "< Address of access"]
    pub address: u64,
    #[doc = "< Log2 of size of access"]
    pub log2_size: ::std::os::raw::c_int,
    #[doc = "< Hash of data before access"]
    pub read_hash: cm_hash,
    #[doc = "< Data before access"]
    pub read_data: *mut u8,
    #[doc = "< Size of data before access in bytes"]
    pub read_data_size: usize,
    #[doc = "< Hash of data after access (if writing)"]
    pub written_hash: cm_hash,
    #[doc = "< Data after access (if writing)"]
    pub written_data: *mut u8,
    #[doc = "< Size of data after access in bytes"]
    pub written_data_size: usize,
    #[doc = "< Sibling hashes towards root"]
    pub sibling_hashes: *mut cm_hash_array,
}
#[test]
fn bindgen_test_layout_cm_access() {
    const UNINIT: ::std::mem::MaybeUninit<cm_access> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_access>(),
        128usize,
        concat!("Size of: ", stringify!(cm_access))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_access>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_access))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(log2_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_hash) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(read_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(read_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_data_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(read_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).written_hash) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(written_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).written_data) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(written_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).written_data_size) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(written_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sibling_hashes) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access),
            "::",
            stringify!(sibling_hashes)
        )
    );
}
#[doc = " \\brief Array of accesses"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_access_array {
    pub entry: *mut cm_access,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_cm_access_array() {
    const UNINIT: ::std::mem::MaybeUninit<cm_access_array> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_access_array>(),
        16usize,
        concat!("Size of: ", stringify!(cm_access_array))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_access_array>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_access_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access_array),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access_array),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " \\brief Array of bracket notes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_bracket_note_array {
    pub entry: *mut cm_bracket_note,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_cm_bracket_note_array() {
    const UNINIT: ::std::mem::MaybeUninit<cm_bracket_note_array> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_bracket_note_array>(),
        16usize,
        concat!("Size of: ", stringify!(cm_bracket_note_array))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_bracket_note_array>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_bracket_note_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_bracket_note_array),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_bracket_note_array),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " \\brief Array of notes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_note_array {
    pub entry: *mut *const ::std::os::raw::c_char,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_cm_note_array() {
    const UNINIT: ::std::mem::MaybeUninit<cm_note_array> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_note_array>(),
        16usize,
        concat!("Size of: ", stringify!(cm_note_array))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_note_array>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_note_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_note_array),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_note_array),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " \\brief Log of state accesses"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_access_log {
    #[doc = "< List of accesses"]
    pub accesses: cm_access_array,
    #[doc = "< Begin/End annotations"]
    pub brackets: cm_bracket_note_array,
    #[doc = "< Per-access annotations"]
    pub notes: cm_note_array,
    #[doc = "< Log type"]
    pub log_type: cm_access_log_type,
}
#[test]
fn bindgen_test_layout_cm_access_log() {
    const UNINIT: ::std::mem::MaybeUninit<cm_access_log> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_access_log>(),
        56usize,
        concat!("Size of: ", stringify!(cm_access_log))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_access_log>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_access_log))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accesses) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access_log),
            "::",
            stringify!(accesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brackets) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access_log),
            "::",
            stringify!(brackets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access_log),
            "::",
            stringify!(notes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_access_log),
            "::",
            stringify!(log_type)
        )
    );
}
#[doc = " \\brief Concurrency runtime configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_concurrency_runtime_config {
    pub update_merkle_tree: u64,
}
#[test]
fn bindgen_test_layout_cm_concurrency_runtime_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_concurrency_runtime_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_concurrency_runtime_config>(),
        8usize,
        concat!("Size of: ", stringify!(cm_concurrency_runtime_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_concurrency_runtime_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_concurrency_runtime_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_merkle_tree) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_concurrency_runtime_config),
            "::",
            stringify!(update_merkle_tree)
        )
    );
}
#[doc = " \\brief HTIF runtime configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_htif_runtime_config {
    pub no_console_putchar: bool,
}
#[test]
fn bindgen_test_layout_cm_htif_runtime_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_htif_runtime_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_htif_runtime_config>(),
        1usize,
        concat!("Size of: ", stringify!(cm_htif_runtime_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_htif_runtime_config>(),
        1usize,
        concat!("Alignment of ", stringify!(cm_htif_runtime_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_console_putchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_htif_runtime_config),
            "::",
            stringify!(no_console_putchar)
        )
    );
}
#[doc = " \\brief Machine runtime configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_machine_runtime_config {
    pub concurrency: cm_concurrency_runtime_config,
    pub htif: cm_htif_runtime_config,
    pub skip_root_hash_check: bool,
    pub skip_version_check: bool,
}
#[test]
fn bindgen_test_layout_cm_machine_runtime_config() {
    const UNINIT: ::std::mem::MaybeUninit<cm_machine_runtime_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_machine_runtime_config>(),
        16usize,
        concat!("Size of: ", stringify!(cm_machine_runtime_config))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_machine_runtime_config>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_machine_runtime_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).concurrency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_runtime_config),
            "::",
            stringify!(concurrency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htif) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_runtime_config),
            "::",
            stringify!(htif)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_root_hash_check) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_runtime_config),
            "::",
            stringify!(skip_root_hash_check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_version_check) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_machine_runtime_config),
            "::",
            stringify!(skip_version_check)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_machine_tag {
    _unused: [u8; 0],
}
#[doc = " \\brief Machine instance handle\n \\details cm_machine* is handle used from C api users\n to pass the machine object when calling C api functions. Currently,\n it is merely a pointer to internal C++ object that is  internally casted\n back to original C++ machine type. On some obscure CPU arhitectures\n where pointer size depend on types, this api might not work"]
pub type cm_machine = cm_machine_tag;
#[doc = " \\brief Semantic version"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_semantic_version {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
    pub pre_release: *const ::std::os::raw::c_char,
    pub build: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cm_semantic_version() {
    const UNINIT: ::std::mem::MaybeUninit<cm_semantic_version> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_semantic_version>(),
        32usize,
        concat!("Size of: ", stringify!(cm_semantic_version))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_semantic_version>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_semantic_version))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_semantic_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_semantic_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_semantic_version),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_semantic_version),
            "::",
            stringify!(pre_release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).build) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_semantic_version),
            "::",
            stringify!(build)
        )
    );
}
#[doc = " \\brief Memory range description"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_memory_range_descr {
    pub start: u64,
    pub length: u64,
    pub description: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cm_memory_range_descr() {
    const UNINIT: ::std::mem::MaybeUninit<cm_memory_range_descr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_memory_range_descr>(),
        24usize,
        concat!("Size of: ", stringify!(cm_memory_range_descr))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_memory_range_descr>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_memory_range_descr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_descr),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_descr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_descr),
            "::",
            stringify!(description)
        )
    );
}
#[doc = " \\brief Memory range description array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm_memory_range_descr_array {
    pub entry: *mut cm_memory_range_descr,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_cm_memory_range_descr_array() {
    const UNINIT: ::std::mem::MaybeUninit<cm_memory_range_descr_array> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cm_memory_range_descr_array>(),
        16usize,
        concat!("Size of: ", stringify!(cm_memory_range_descr_array))
    );
    assert_eq!(
        ::std::mem::align_of::<cm_memory_range_descr_array>(),
        8usize,
        concat!("Alignment of ", stringify!(cm_memory_range_descr_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_descr_array),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cm_memory_range_descr_array),
            "::",
            stringify!(count)
        )
    );
}
extern "C" {
    #[doc = " \\brief Create new machine config with default parameters\n \\returns Pointer to new default config object\n \\details Object acquired from this function must not be changed and\n must be deleted with cm_delete_machine_config. To make a custom config based\n on default config user must make a deep copy of returned object members and then\n customize"]
    pub fn cm_new_default_machine_config() -> *const cm_machine_config;
}
extern "C" {
    #[doc = " \\brief Delete machine config acquired from cm_new_default_machine_config\n \\returns void"]
    pub fn cm_delete_machine_config(config: *const cm_machine_config);
}
extern "C" {
    #[doc = " \\brief Create new machine instance from configuration\n \\param config Machine configuration. Must be pointer to valid object\n \\param runtime_config Machine runtime configuration. Must be pointer to valid object\n \\param new_machine Receives the pointer to new machine instance\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_create_machine(
        config: *const cm_machine_config,
        runtime_config: *const cm_machine_runtime_config,
        new_machine: *mut *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create machine instance from previously serialized directory\n \\param dir Directory where previous machine is serialized\n \\param runtime_config Machine runtime configuration. Must be pointer to valid object\n \\param new_machine Receives the pointer to new machine instance\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_load_machine(
        dir: *const ::std::os::raw::c_char,
        runtime_config: *const cm_machine_runtime_config,
        new_machine: *mut *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Serialize entire state to directory\n \\param m Pointer to valid machine instance\n \\param dir Directory where the machine will be serialized\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\details The method changes machine because it updates the root hash\n \\returns 0 for success, non zero code for error"]
    pub fn cm_store(
        m: *mut cm_machine,
        dir: *const ::std::os::raw::c_char,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deletes machine instance\n \\param m Valid pointer to the existing machine instance"]
    pub fn cm_delete_machine(m: *mut cm_machine);
}
extern "C" {
    #[doc = " \\brief Runs the machine until mcycle reaches mcycle_end or the machine halts.\n \\param m Pointer to valid machine instance\n \\param mcycle_end End cycle value\n \\param break_reason Receives reason for machine run interruption when not NULL\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_machine_run(
        m: *mut cm_machine,
        mcycle_end: u64,
        break_reason_result: *mut CM_BREAK_REASON,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Runs the machine for one micro cycle logging all accesses to the state.\n \\param m Pointer to valid machine instance\n \\param log_type Type of access log to generate.\n \\param one_based Use 1-based indices when reporting errors.\n \\param access_log Receives the state access log.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_log_uarch_step(
        m: *mut cm_machine,
        log_type: cm_access_log_type,
        one_based: bool,
        access_log: *mut *mut cm_access_log,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief  Deletes the instance of cm_access_log acquired from cm_step\n \\param acc_log Valid pointer to cm_access_log object"]
    pub fn cm_delete_access_log(acc_log: *mut cm_access_log);
}
extern "C" {
    #[doc = " \\brief Checks the internal consistency of an access log\n \\param log State access log to be verified\n \\param r Machine runtime configuration to use during verification. Must be pointer to valid object\n \\param one_based Use 1-based indices when reporting errors\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_verify_uarch_step_log(
        log: *const cm_access_log,
        runtime_config: *const cm_machine_runtime_config,
        one_based: bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Checks the validity of a state transition\n \\param root_hash_before State hash before step\n \\param log Step state access log\n \\param root_hash_after State hash after step\n \\param runtime_config Machine runtime configuration to use during verification. Must be pointer to valid object\n \\param one_based Use 1-based indices when reporting errors\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for successful verification, non zero code for error"]
    pub fn cm_verify_uarch_step_state_transition(
        root_hash_before: *const cm_hash,
        log: *const cm_access_log,
        root_hash_after: *const cm_hash,
        runtime_config: *const cm_machine_runtime_config,
        one_based: bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Checks the validity of a state transition caused by a uarch state reset\n \\param root_hash_before State hash before step\n \\param log Step state access log produced by cm_log_uarch_reset\n \\param root_hash_after State hash after step\n \\param runtime_config Machine runtime configuration to use during verification. Must be pointer to valid object\n \\param one_based Use 1-based indices when reporting errors\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for successful verification, non zero code for error"]
    pub fn cm_verify_uarch_reset_state_transition(
        root_hash_before: *const cm_hash,
        log: *const cm_access_log,
        root_hash_after: *const cm_hash,
        runtime_config: *const cm_machine_runtime_config,
        one_based: bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Checks the internal consistency of an access log produced by cm_log_uarch_reset\n \\param log State access log to be verified\n \\param r Machine runtime configuration to use during verification. Must be pointer to valid object\n \\param one_based Use 1-based indices when reporting errors\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_verify_uarch_reset_log(
        log: *const cm_access_log,
        runtime_config: *const cm_machine_runtime_config,
        one_based: bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Obtains the proof for a node in the Merkle tree\n \\param m Pointer to valid machine instance\n \\param address Address of target node. Must be aligned to a 2<sup>log2_size</sup> boundary\n \\param log2_size log<sub>2</sub> of size subintended by target node.\n Must be between 3 (for a word) and 64 (for the entire address space), inclusive\n \\param proof Receives the proof\n proof must be deleted with the function cm_delete_merkle_tree_proof\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error\n \\details If the node is smaller than a page size, then it must lie entirely inside the same PMA range."]
    pub fn cm_get_proof(
        m: *const cm_machine,
        address: u64,
        log2_size: ::std::os::raw::c_int,
        proof: *mut *mut cm_merkle_tree_proof,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief  Deletes the instance of cm_merkle_tree_proof acquired from cm_get_proof\n \\param proof Valid pointer to cm_merkle_tree_proof object"]
    pub fn cm_delete_merkle_tree_proof(proof: *mut cm_merkle_tree_proof);
}
extern "C" {
    #[doc = " \\brief Obtains the root hash of the Merkle tree\n \\param m Pointer to valid machine instance\n \\param hash Valid pointer to cm_hash structure that  receives the hash.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_get_root_hash(
        m: *const cm_machine,
        hash: *mut cm_hash,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Verifies integrity of Merkle tree.\n \\param m Pointer to valid machine instance\n \\param result True if tree is self-consistent, false otherwise.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_verify_merkle_tree(
        m: *const cm_machine,
        result: *mut bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read the value of any CSR\n \\param m Pointer to valid machine instance\n \\param val Receives value read from the CSR\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_csr(
        m: *const cm_machine,
        r: CM_PROC_CSR,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Write the value of any CSR\n \\param m Pointer to valid machine instance\n \\param w CSR to write\n \\param val Value to write\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_csr(
        m: *mut cm_machine,
        w: CM_PROC_CSR,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Gets the address of any CSR\n \\param w The CSR\n \\returns The address of the specified CSR"]
    pub fn cm_get_csr_address(w: CM_PROC_CSR) -> u64;
}
extern "C" {
    #[doc = " \\brief Read the value of a word in the machine state.\n \\param m Pointer to valid machine instance\n \\param word_address Word address (aligned to 64-bit boundary).\n \\param word_value Receives word value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error\n \\warning The current implementation of this function is very slow!"]
    pub fn cm_read_word(
        m: *const cm_machine,
        word_address: u64,
        word_value: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads a chunk of data from the machine memory.\n \\param m Pointer to valid machine instance\n \\param address Physical address to start reading.\n \\param data Receives chunk of memory.\n \\param length Size of chunk.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error\n \\details The entire chunk, from \\p address to \\p address + \\p length must\n be inside the same PMA region."]
    pub fn cm_read_memory(
        m: *const cm_machine,
        address: u64,
        data: *mut ::std::os::raw::c_uchar,
        length: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes a chunk of data to the machine memory.\n \\param m Pointer to valid machine instance\n \\param address Physical address to start writing.\n \\param data Source for chunk of data.\n \\param length Size of chunk.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error\n \\details The entire chunk, from \\p address to \\p address + \\p length must\n be inside the same PMA region. Moreover, this PMA must be a memory PMA,\n and not a device PMA."]
    pub fn cm_write_memory(
        m: *mut cm_machine,
        address: u64,
        data: *const ::std::os::raw::c_uchar,
        length: usize,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads a chunk of data from the machine virtual memory.\n \\param m Pointer to valid machine instance\n \\param address Virtual address to start reading.\n \\param data Receives chunk of memory.\n \\param length Size of chunk.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_virtual_memory(
        m: *const cm_machine,
        address: u64,
        data: *mut ::std::os::raw::c_uchar,
        length: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes a chunk of data to the machine virtual memory.\n \\param m Pointer to valid machine instance\n \\param address Virtual address to start writing.\n \\param data Source for chunk of data.\n \\param length Size of chunk.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_virtual_memory(
        m: *mut cm_machine,
        address: u64,
        data: *const ::std::os::raw::c_uchar,
        length: usize,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of a general-purpose register.\n \\param m Pointer to valid machine instance\n \\param i Register index. Between 0 and X_REG_COUNT-1, inclusive.\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_x(
        m: *const cm_machine,
        i: ::std::os::raw::c_int,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of a general-purpose register.\n \\param m Pointer to valid machine instance\n \\param i Register index. Between 1 and X_REG_COUNT-1, inclusive.\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_x(
        m: *mut cm_machine,
        i: ::std::os::raw::c_int,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Gets the address of a general-purpose register.\n \\param i Register index. Between 0 and X_REG_COUNT-1, inclusive.\n \\returns Address of the specified register"]
    pub fn cm_get_x_address(i: ::std::os::raw::c_int) -> u64;
}
extern "C" {
    #[doc = " \\brief Gets the address of a general-purpose microarchitecture register.\n \\param i Register index. Between 0 and UARCH_X_REG_COUNT-1, inclusive.\n \\returns Address of the specified register"]
    pub fn cm_get_uarch_x_address(i: ::std::os::raw::c_int) -> u64;
}
extern "C" {
    #[doc = " \\brief Reads the value of a floating-point register.\n \\param m Pointer to valid machine instance\n \\param i Register index. Between 0 and F_REG_COUNT-1, inclusive.\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_f(
        m: *const cm_machine,
        i: ::std::os::raw::c_int,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of a floating-point register.\n \\param m Pointer to valid machine instance\n \\param i Register index. Between 0 and F_REG_COUNT-1, inclusive.\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_f(
        m: *mut cm_machine,
        i: ::std::os::raw::c_int,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Gets the address of a floating-point register.\n \\param i Register index. Between 0 and F_REG_COUNT-1, inclusive.\n \\returns Address of the specified register"]
    pub fn cm_get_f_address(i: ::std::os::raw::c_int) -> u64;
}
extern "C" {
    #[doc = " \\brief Reads the value of the pc register.\n \\param m Pointer to valid machine instance\n \\param val Receives the value of the register\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_pc(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the pc register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_pc(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the fcsr register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_fcsr(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the fcsr register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_fcsr(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mvendorid register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mvendorid(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the marchid register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_marchid(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mimpid register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mimpid(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mcycle register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mcycle(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the mcycle register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mcycle(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the icycleinstret register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_icycleinstret(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the icycleinstret register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_icycleinstret(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mstatus register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mstatus(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the mstatus register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mstatus(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the menvcfg register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_menvcfg(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the menvcfg register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_menvcfg(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mtvec register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mtvec(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the mtvec register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mtvec(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mscratch register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mscratch(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the mscratch register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mscratch(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mepc register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mepc(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the mepc register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mepc(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mcause register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mcause(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the mcause register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mcause(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mtval register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mtval(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the mtval register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mtval(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the misa register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_misa(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the misa register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_misa(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mie register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mie(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mie register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mie(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mip register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mip(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mip register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mip(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the medeleg register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_medeleg(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the medeleg register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_medeleg(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mideleg register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mideleg(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the mideleg register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mideleg(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the mcounteren register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_mcounteren(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the mcounteren register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_mcounteren(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the stvec register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_stvec(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the stvec register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_stvec(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the sscratch register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_sscratch(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the sscratch register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_sscratch(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the sepc register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_sepc(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the sepc register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_sepc(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the scause register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_scause(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the scause register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_scause(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the stval register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_stval(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the stval register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_stval(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the satp register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_satp(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the satp register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_satp(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the scounteren register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_scounteren(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the scounteren register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_scounteren(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the senvcfg register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_senvcfg(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the senvcfg register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_senvcfg(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the ilrsc register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_ilrsc(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the ilrsc register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_ilrsc(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the iflags register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_iflags(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns packed iflags from its component fields.\n \\param val Receives value of the register."]
    pub fn cm_packed_iflags(
        PRV: ::std::os::raw::c_int,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        H: ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    #[doc = " \\brief Reads the value of the iflags register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_iflags(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of HTIF's tohost register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_htif_tohost(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the device field of HTIF's tohost register.\n \\param m Pointer to valid machine instance\n \\param val Receives the value of the field\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_htif_tohost_dev(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the command field of HTIF's tohost register.\n \\param m Pointer to valid machine instance\n \\param val Receives the value of the field\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_htif_tohost_cmd(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the data field of HTIF's tohost register.\n \\param m Pointer to valid machine instance\n \\param val Receives the value of the field\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_htif_tohost_data(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of HTIF's tohost register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_htif_tohost(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of HTIF's fromhost register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_htif_fromhost(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of HTIF's fromhost register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_htif_fromhost(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the data field in HTIF's fromhost register.\n \\param m Pointer to valid machine instance\n \\param val New value for the field.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_htif_fromhost_data(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of HTIF's halt register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_htif_ihalt(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of HTIF's halt register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_htif_ihalt(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of HTIF's console register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_htif_iconsole(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of HTIF's console register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_htif_iconsole(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of HTIF's yield register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_htif_iyield(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of HTIF's yield register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_htif_iyield(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of CLINT's mtimecmp register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_clint_mtimecmp(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of CLINT's mtimecmp register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_clint_mtimecmp(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Checks the value of the iflags_X flag.\n \\param m Pointer to valid machine instance\n \\param val Receives the flag value\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_iflags_X(
        m: *const cm_machine,
        val: *mut bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Resets the value of the iflags_X flag.\n \\param m Pointer to valid machine instance\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_reset_iflags_X(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Sets the iflags_X flag.\n \\param m Pointer to valid machine instance\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_set_iflags_X(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Checks the value of the iflags_Y flag.\n \\param m Pointer to valid machine instance\n \\param val Receives the flag value\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_iflags_Y(
        m: *const cm_machine,
        val: *mut bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Resets the value of the iflags_Y flag.\n \\param m Pointer to valid machine instance\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_reset_iflags_Y(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Sets the iflags_Y flag.\n \\param m Pointer to valid machine instance\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_set_iflags_Y(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Checks the value of the iflags_H flag.\n \\param m Pointer to valid machine instance\n \\param val Receives the flag value\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_iflags_H(
        m: *const cm_machine,
        val: *mut bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Sets the iflags_H flag.\n \\param m Pointer to valid machine instance\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_set_iflags_H(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Verify if dirty page maps are consistent.\n \\param m Pointer to valid machine instance\n \\param result True if dirty page maps are consistent, false if there is an error.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_verify_dirty_page_maps(
        m: *const cm_machine,
        result: *mut bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns copy of initialization config.\n \\param m Pointer to valid machine instance\n \\param config Receives the initial configuration.\n It should be deleted with cm_delete_machine_config.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error\n \\details Object acquired from this function must not be changed and\n must be deleted with cm_delete_machine_config"]
    pub fn cm_get_initial_config(
        m: *const cm_machine,
        config: *mut *const cm_machine_config,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns copy of default system config.\n \\param config Receives the default configuration.\n It should be deleted with cm_delete_machine_config\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error\n \\details Object acquired from this function must not be changed and\n must be deleted with cm_delete_machine_config"]
    pub fn cm_get_default_config(
        config: *mut *const cm_machine_config,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Replaces a memory range\n \\param m Pointer to valid machine instance\n \\param new_range Configuration of the new memory range\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error\n \\details The machine must contain an existing memory range matching the start and length specified in new_range"]
    pub fn cm_replace_memory_range(
        m: *mut cm_machine,
        new_range: *const cm_memory_range_config,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deletes a machine memory range config\n \\returns void"]
    pub fn cm_delete_memory_range_config(config: *const cm_memory_range_config);
}
extern "C" {
    #[doc = " \\brief Deletes the error message\n \\param err_msg Pointer to error message received from some other function\n \\details This C API is meant to be used for various language bindings.\n Many of them could not directly call C free function,\n so this is a convenience function for cleanup of error messages"]
    pub fn cm_delete_cstring(err_msg: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief Deletes machine runtime config\n \\returns void"]
    pub fn cm_delete_machine_runtime_config(config: *const cm_machine_runtime_config);
}
extern "C" {
    #[doc = " \\brief Deletes allocated microarchitecture ram config\n \\returns void"]
    pub fn cm_delete_uarch_ram_config(config: *const cm_uarch_ram_config);
}
extern "C" {
    #[doc = " \\brief Deletes allocated dhd microarchitecture config\n \\returns void"]
    pub fn cm_delete_uarch_config(config: *const cm_uarch_config);
}
extern "C" {
    #[doc = " \\brief Deletes semantic version instance\n \\param m Valid pointer to the existing semantic version instance"]
    pub fn cm_delete_semantic_version(version: *const cm_semantic_version);
}
extern "C" {
    #[doc = " \\brief Destroys machine\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_destroy(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Do a snapshot of the machine\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_snapshot(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Performs rollback\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_rollback(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of a microarchitecture general-purpose register.\n \\param m Pointer to valid machine instance\n \\param i Register index. Between 0 and UARCH_X_REG_COUNT-1, inclusive.\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_uarch_x(
        m: *const cm_machine,
        i: ::std::os::raw::c_int,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of a microarchitecture general-purpose register.\n \\param m Pointer to valid machine instance\n \\param i Register index. Between 1 and UARCH_X_REG_COUNT-1, inclusive.\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_uarch_x(
        m: *mut cm_machine,
        i: ::std::os::raw::c_int,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the microarchitecture pc register.\n \\param m Pointer to valid machine instance\n \\param val Receives the value of the register\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_uarch_pc(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the microarchitecture pc register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_uarch_pc(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reads the value of the microarchitecture cycle register.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the register.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_uarch_cycle(
        m: *const cm_machine,
        val: *mut u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Writes the value of the microarchitecture cycle register.\n \\param m Pointer to valid machine instance\n \\param val New register value.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_write_uarch_cycle(
        m: *mut cm_machine,
        val: u64,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Gets the value of the microarchitecture halt flag.\n \\param m Pointer to valid machine instance\n \\param val Receives value of the halt flag.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successfull function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring\n \\returns 0 for success, non zero code for error"]
    pub fn cm_read_uarch_halt_flag(
        m: *const cm_machine,
        val: *mut bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Sets the value of the microarchitecture halt flag.\n \\param m Pointer to valid machine instance\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successfull function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring\n \\returns 0 for success, non zero code for error"]
    pub fn cm_set_uarch_halt_flag(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Resets the value of the microarchitecture halt flag.\n \\param m Pointer to valid machine instance\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successfull function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring\n \\returns 0 for success, non zero code for error"]
    pub fn cm_reset_uarch(
        m: *mut cm_machine,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Resets the value of the microarchitecture halt flag.\n \\param m Pointer to valid machine instance\n \\param log_type Type of access log to generate.\n \\param one_based Use 1-based indices when reporting errors.\n \\param access_log Receives the state access log.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successfull function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring\n \\returns 0 for success, non zero code for error"]
    pub fn cm_log_uarch_reset(
        m: *mut cm_machine,
        log_type: cm_access_log_type,
        one_based: bool,
        access_log: *mut *mut cm_access_log,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Runs the machine in the microarchitecture until the mcycle advances by one unit or the micro cycles counter\n (uarch_cycle) reaches uarch_cycle_end\n \\param m Pointer to valid machine instance\n \\param mcycle_end End cycle value\n \\param status_result Receives status of machine run_uarch when not NULL\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_machine_run_uarch(
        m: *mut cm_machine,
        uarch_cycle_end: u64,
        status_result: *mut CM_UARCH_BREAK_REASON,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns an array with the description of each memory range in the machine.\n \\param m Pointer to valid machine instance\n \\param mrda Receives pointer to array of memory range descriptions. Must be deleted by the function caller using\n cm_delete_memory_range_descr_array.\n \\param err_msg Receives the error message if function execution fails\n or NULL in case of successful function execution. In case of failure error_msg\n must be deleted by the function caller using cm_delete_cstring.\n err_msg can be NULL, meaning the error message won't be received.\n \\returns 0 for success, non zero code for error"]
    pub fn cm_get_memory_ranges(
        m: *mut cm_machine,
        mrda: *mut *mut cm_memory_range_descr_array,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Delete memory range description array acquired from cm_get_memory_ranges.\n \\param mrda Pointer to array of memory range descriptions to delete.\n \\returns void"]
    pub fn cm_delete_memory_range_descr_array(mrda: *mut cm_memory_range_descr_array);
}
